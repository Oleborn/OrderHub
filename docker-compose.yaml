# =============================================================================
# DOCKER COMPOSE ДЛЯ ORDERHUB - ПОЛНЫЙ СТЕК
# =============================================================================
# Запуск: docker-compose --env-file .env up -d
# Остановка: docker-compose down -v (удалит volumes)
#
# Компоненты:
#   postgres     - база данных (хранит заказы)
#   orderhub-app - само приложение Spring Boot
#   prometheus   - сбор метрик (хранит 15 дней)
#   grafana      - визуализация (дашборды)
# =============================================================================

services:
  # ---------------------------------------------------------------------------
  # PostgreSQL - Production-ready конфигурация
  # ---------------------------------------------------------------------------
  postgres:
    image: postgres:15-alpine
    container_name: postgres_orderhub
    ports:
      - "${POSTGRES_PORT}:5432"  # Проброс порта для внешних подключений (например, DBeaver)
    environment:
      # ВСЕ секреты берутся из .env файла, НЕ хардкодим!
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Персистентность данных БД
    restart: unless-stopped  # Автоматический перезапуск при падении (production)
    command:
      # Тюнинг PostgreSQL для лучшей производительности
      - "postgres"
      - "-c"
      - "max_connections=100"      # Максимум подключений (не даём упасть от перегрузки)
      - "-c"
      - "shared_buffers=256MB"      # Кэш в памяти (ускоряет запросы)
    networks:
      - orderhub-network  # Изолированная сеть для сервисов
    healthcheck:
      # Проверка, что БД действительно готова принимать подключения
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s   # Проверять каждые 10 секунд
      timeout: 5s     # Ждать ответа не больше 5 секунд
      retries: 5      # 5 неудач = контейнер нездоров

  # ---------------------------------------------------------------------------
  # Spring Boot приложение
  # ---------------------------------------------------------------------------
  order-service:
    build:
      context: .       # Текущая директория
      dockerfile: order-service/Dockerfile         # Используем наш multi-stage Dockerfile
      args:
        # Аргументы сборки (только метаинформация, НЕ секреты!)
        APP_VERSION: ${APP_VERSION:-1.0.0}  # Версия приложения для меток в образе
        # ВНИМАНИЕ: Пароли НЕ передаём в ARGS! Они останутся в образе.
    container_name: order_service
    ports:
      - "${ORDER_SERVICE_PORT:-8081}:8081"           # Проброс порта наружу
    environment:
      # Сервер
      SERVER_PORT: 8081

      # -----------------------------------------------------------------------
      # Подключение к БД (runtime)
      # -----------------------------------------------------------------------
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/${POSTGRES_DB}
      SPRING_DATASOURCE_USERNAME: ${POSTGRES_USER}
      SPRING_DATASOURCE_PASSWORD: ${POSTGRES_PASSWORD}  # Секрет!

      # -----------------------------------------------------------------------
      # Для миграций и прямых запросов (если нужно внутри приложения)
      # -----------------------------------------------------------------------
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}           # Секрет!

      # -----------------------------------------------------------------------
      # JPA настройки
      # -----------------------------------------------------------------------
      SPRING_JPA_HIBERNATE_DDL_AUTO: ${SPRING_JPA_HIBERNATE_DDL_AUTO}  # validate в production

      # -----------------------------------------------------------------------
      # Метрики и мониторинг (для Prometheus)
      # -----------------------------------------------------------------------
      MANAGEMENT_METRICS_EXPORT_PROMETHEUS_ENABLED: "true"  # Включаем экспорт в Prometheus
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,prometheus,metrics,loggers

      # -----------------------------------------------------------------------
      # Логирование (опционально, для отладки)
      # -----------------------------------------------------------------------
      LOGGING_LEVEL_COM_ORDERHUB: DEBUG  # Детальные логи нашего кода

      # Трассировка OpenTelemetry
      MANAGEMENT_TRACING_ENABLED: "true"
      MANAGEMENT_TRACING_SAMPLING_PROBABILITY: "1.0"
      MANAGEMENT_OTLP_TRACING_ENDPOINT: http://jaeger:4318/v1/traces

      # Логирование с traceId
      LOGGING_PATTERN_CONSOLE: "%d{yyyy-MM-dd HH:mm:ss} - %X{traceId} - %msg%n"
      LOGGING_LEVEL_OLEBORN_ORDERHUB: DEBUG

      NOTIFICATION_SERVICE_URL: ${NOTIFICATION_SERVICE_URL}

    depends_on:
      postgres:
        condition: service_healthy  # Ждём, пока PostgreSQL полностью готов
    restart: unless-stopped
    healthcheck:
      # Проверка, что Spring Boot жив и отвечает
      test: ["CMD", "curl", "-f", "http://localhost:8081/actuator/health"]
      interval: 30s      # Реже, чем у БД (Spring Boot тяжелее стартует)
      timeout: 10s
      retries: 3
      start_period: 40s  # Даём время на запуск (первые 40с не проверяем)
    networks:
      - orderhub-network

  # ---------------------------------------------------------------------------
  # Notification Service - сервис уведомлений
  # ---------------------------------------------------------------------------
  notification-service:
    build:
      context: .
      dockerfile: notification-service/Dockerfile
      args:
        APP_VERSION: ${APP_VERSION:-1.0.0}
    container_name: notification_service
    ports:
      - "${NOTIFICATION_SERVICE_PORT:-8082}:8082"
    environment:
      # Сервер
      SERVER_PORT: 8082

      # Метрики для Prometheus (опционально)
      MANAGEMENT_METRICS_EXPORT_PROMETHEUS_ENABLED: "true"
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,info,prometheus,metrics

      # Трассировка OpenTelemetry
      MANAGEMENT_TRACING_ENABLED: "true"
      MANAGEMENT_TRACING_SAMPLING_PROBABILITY: "1.0"
      MANAGEMENT_OTLP_TRACING_ENDPOINT: http://jaeger:4318/v1/traces

      # Логирование с traceId
      LOGGING_PATTERN_CONSOLE: "%d{yyyy-MM-dd HH:mm:ss} - %X{traceId} - %msg%n"
      LOGGING_LEVEL_OLEBORN_ORDERHUB: DEBUG
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy  # Ждём, пока PostgreSQL полностью готов
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8082/actuator/health" ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - orderhub-network

  # ---------------------------------------------------------------------------
  # Prometheus - сбор метрик
  # ---------------------------------------------------------------------------
  prometheus:
    image: prom/prometheus:v2.47.0
    container_name: prometheus_orderhub
    volumes:
      # Конфигурация Prometheus (скажем, куда ходить за метриками)
      - ./order-service/src/main/resources/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      # Данные метрик (чтобы не терять историю при перезапуске)
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=15d'  # Храним метрики 15 дней (production standard)
    ports:
      - '9090:9090'  # UI Prometheus (только для отладки)
    restart: unless-stopped
    networks:
      - orderhub-network

  # ---------------------------------------------------------------------------
  # Grafana - визуализация дашбордов
  # ---------------------------------------------------------------------------
  grafana:
    image: grafana/grafana:10.2.2
    container_name: grafana_orderhub
    volumes:
      - grafana_data:/var/lib/grafana  # Сохраняем дашборды и настройки
    environment:
      # Учётка для первого входа (обязательно поменять в production!)
      GF_SECURITY_ADMIN_USER: ${GRAFANA_ADMIN_USER}
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD}
      # Дополнительные плагины (например, для круговых диаграмм)
      GF_INSTALL_PLUGINS: grafana-piechart-panel
    ports:
      - '3000:3000'  # UI Grafana
    depends_on:
      - prometheus  # Логически зависит, но технически может работать без него
    restart: unless-stopped
    networks:
      - orderhub-network

  # ---------------------------------------------------------------------------
  # Jaeger - распределённая трассировка
  # ---------------------------------------------------------------------------
  jaeger:
    image: jaegertracing/all-in-one:1.52
    container_name: jaeger
    ports:
      - "16686:16686"  # UI
      - "4317:4317"    # OTLP gRPC
      - "4318:4318"    # OTLP HTTP
    environment:
      COLLECTOR_OTLP_ENABLED: "true"
      # Храним трассы в памяти (для демо), в production нужен persistent storage
      SPAN_STORAGE_TYPE: memory
    restart: unless-stopped
    networks:
      - orderhub-network

# -------------------------------------------------------------------------------
# Persistent volumes - данные НЕ теряются при docker-compose down
# -------------------------------------------------------------------------------
volumes:
  postgres_data:
    name: orderhub_postgres_data      # Явное имя для удобства
  prometheus_data:
    name: orderhub_prometheus_data
  grafana_data:
    name: orderhub_grafana_data
  jaeger_data:
    name: orderhub_jaeger_data

# -------------------------------------------------------------------------------
# Изолированная сеть для сервисов
# -------------------------------------------------------------------------------
networks:
  orderhub-network:
    name: orderhub-network
    driver: bridge  # Стандартный драйвер для изоляции