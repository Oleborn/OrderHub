# Grafana. Руководство по визуализации и анализу данных

**Автор:** Oleborn

**Дата:** 14 февраля 2026 г.

**Проект:** [OrderHub](https://github.com/Oleborn/OrderHub)

---

## 1. Введение: Grafana как центральный хаб Observability

Grafana давно перестала быть просто инструментом для построения графиков. Сегодня это полноценная платформа, которая объединяет метрики, логи и трассировки в единый, интерактивный интерфейс, предоставляя глубокое понимание состояния распределенных систем. Она является критически важным компонентом любой современной стратегии Observability, позволяя инженерам и бизнесу принимать решения на основе данных.

В этом фундаментальном руководстве мы погрузимся в самые глубокие аспекты Grafana, исследуя её архитектуру, продвинутые возможности визуализации, автоматизации и масштабирования, а также интеграцию с другими инструментами экосистемы Grafana Labs. Мы выйдем за рамки базовых дашбордов и рассмотрим техники, используемые в production-ready средах.

---

## 2. Архитектура Grafana: Глубокий анализ компонентов

Grafana — это сложная система, состоящая из нескольких ключевых компонентов, работающих в гармонии. Понимание их взаимодействия критически важно для эффективного использования и масштабирования платформы.

### 2.1. Backend: Мощь Go и расширяемость

Серверная часть Grafana, написанная на Go, является сердцем платформы. Она отвечает за:

- **API Gateway:** Все запросы от Frontend и внешних систем проходят через Backend. Он обеспечивает маршрутизацию, аутентификацию и авторизацию.

- **Data Source Proxy:** Backend выступает в роли прокси для запросов к источникам данных. Это решает проблемы CORS, скрывает учетные данные источников данных от клиента и позволяет применять серверную логику (например, кэширование).

- **Query Engine:** Хотя Grafana не хранит данные, Backend содержит логику для построения запросов к различным источникам данных и их агрегации.

- **Alerting Engine:** В Grafana 9+ реализована унифицированная система алертинга, которая полностью работает на Backend. Она выполняет правила, обрабатывает состояния алертов и отправляет уведомления.

- **Provisioning Engine:** Отвечает за автоматическую загрузку конфигураций (дашбордов, источников данных, нотификаций) из файлов.

- **Database:** Grafana использует реляционную базу данных (SQLite по умолчанию, PostgreSQL или MySQL для production) для хранения метаданных: пользователей, организаций, дашбордов (их JSON-определений), источников данных, настроек алертов и сессий.

- **Plugin Management:** Backend управляет жизненным циклом плагинов, их загрузкой и взаимодействием с системой.

### 2.2. Frontend: Интерактивность React и TypeScript

Клиентская часть Grafana — это высокоинтерактивное одностраничное приложение (SPA), разработанное с использованием React и TypeScript. Она отвечает за:

- **Рендеринг дашбордов:** Отображение графиков, таблиц и других визуализаций. Frontend активно использует Canvas API и SVG для отрисовки.

- **Query Editor:** Предоставляет специализированные редакторы запросов для каждого типа источника данных (например, автодополнение PromQL, построитель SQL-запросов).

- **Time Range & Variable Management:** Управление глобальным временным диапазоном и значениями переменных, которые динамически влияют на все панели дашборда.

- **User Interface:** Вся интерактивность, включая drag-and-drop, изменение размеров панелей, настройка визуализаций, происходит на Frontend.

- **State Management:** Frontend поддерживает локальное состояние дашборда, обеспечивая плавное взаимодействие без постоянных запросов к Backend.

### 2.3. Система плагинов: Расширяемость без границ

Плагины — это краеугольный камень расширяемости Grafana. Они позволяют добавлять новые функциональные возможности без изменения основного кода Grafana.

- **Data Source Plugins:** Позволяют Grafana подключаться к новым типам баз данных или API. Например, плагины для Prometheus, Loki, Tempo, Elasticsearch, SQL-баз, AWS CloudWatch, Google Cloud Monitoring и многих других. Каждый плагин предоставляет свой Query Editor и логику обработки данных.

- **Panel Plugins:** Добавляют новые типы визуализаций, выходящие за рамки стандартных графиков и таблиц. Примеры: Worldmap Panel, Gantt Chart Panel, Status Panel.

- **App Plugins:** Позволяют встраивать целые приложения или кастомные страницы в Grafana. Например, плагины для интеграции с Zabbix, ServiceNow или для создания кастомных порталов.

Плагины могут быть написаны на TypeScript/React для Frontend и Go для Backend, что обеспечивает полную гибкость.

---

## 3. Data Sources: Унификация данных из разрозненных систем

Grafana не хранит данные, но она является мастером по их агрегации и визуализации из самых разнообразных источников. Это позволяет создать единый центр управления для всей вашей инфраструктуры и приложений.

### 3.1. Подключение и конфигурация

Источники данных конфигурируются через UI или с помощью Provisioning (см. раздел 6). Для каждого источника указываются:

- **Type:** Тип источника данных (Prometheus, PostgreSQL, Loki и т.д.).

- **URL:** Адрес, по которому Grafana будет обращаться к источнику.

- **Authentication:** Методы аутентификации (Basic Auth, API Key, OAuth, TLS Client Auth).

- **Access Mode:** `Server (Default)` — запросы проксируются через Grafana Backend. `Browser` — запросы идут напрямую из браузера пользователя (менее безопасно, но может быть полезно в специфических случаях).

### 3.2. SQL Data Sources: Мощь реляционных данных в Grafana

Grafana поддерживает подключение к традиционным реляционным базам данных (PostgreSQL, MySQL, MSSQL, Oracle, SQLite). Это открывает огромные возможности для визуализации бизнес-метрик и данных, которые не хранятся в TSDB.

**Пример SQL-запроса для временных рядов (PostgreSQL):**

```sql
SELECT
  $__timeGroupAlias("created_at", $__interval),
  status AS metric,
  count(*) AS value
FROM orders
WHERE
  $__timeFilter("created_at") AND
  status IN ('COMPLETED', 'FAILED')
GROUP BY 1, 2
ORDER BY 1
```

**Объяснение макросов Grafana:**

- `$__timeGroupAlias("created_at", $__interval)`: Этот макрос генерирует функцию группировки по времени (например, `date_trunc('hour', created_at) AS time`) и алиас для столбца времени. `$__interval` автоматически подставляется в зависимости от выбранного временного диапазона на дашборде.

- `$__timeFilter("created_at")`: Генерирует условие `WHERE created_at BETWEEN '...' AND '...'`, используя выбранный временной диапазон.

Эти макросы позволяют создавать динамические SQL-запросы, которые адаптируются к интерактивным элементам дашборда, делая SQL-источники данных невероятно гибкими.

### 3.3. Mixed Data Sources: Объединение миров

Одна из самых мощных функций Grafana — возможность отображать данные из **разных источников на одной панели**. Это позволяет создавать комплексные дашборды, которые коррелируют технические метрики с бизнес-показателями.

**Пример:** На одной панели можно показать:

- QPS из Prometheus (техническая метрика).

- Количество успешно созданных заказов из PostgreSQL (бизнес-метрика).

- Количество ошибок в логах из Loki (логи).

Это дает целостное представление о состоянии системы и позволяет быстро выявлять взаимосвязи между различными аспектами работы приложения.

---

## 4. Панели и Дашборды: Искусство визуализации

Дашборды в Grafana — это не просто набор графиков, это тщательно продуманные композиции, которые рассказывают историю о вашей системе. Эффективный дашборд позволяет быстро понять состояние системы и выявить аномалии.

### 4.1. Типы визуализаций: Выбор правильного инструмента

Grafana предлагает широкий спектр визуализаций, каждая из которых подходит для определенных типов данных и задач:

- **Time Series (ранее Graph):** Самая распространенная визуализация для отображения временных рядов. Поддерживает множество опций: несколько осей Y, пороговые значения (thresholds), заполнение областей, стекирование, аннотации.

- **Stat:** Отображает одно большое числовое значение (например, текущее QPS, средняя задержка). Поддерживает Sparkline, цвета по пороговым значениям.

- **Gauge:** Круговая диаграмма для отображения текущего значения в диапазоне (например, использование CPU в процентах).

- **Bar Gauge:** Линейный аналог Gauge, полезен для сравнения нескольких значений.

- **Table:** Для отображения табличных данных. Поддерживает форматирование столбцов, условное окрашивание.

- **Heatmap:** Визуализирует распределение значений во времени. Идеально подходит для анализа задержек (latency) или использования ресурсов, показывая "горячие" и "холодные" зоны.

- **Logs:** Для отображения логов из Loki или Elasticsearch, с возможностью фильтрации и поиска.

- **Trace:** Для визуализации трассировок из Tempo или Jaeger.

- **Alert list:** Отображает текущие активные алерты.

- **Text:** Для добавления текстовых описаний, заголовков, ссылок и документации прямо на дашборд.

### 4.2. Трансформации (Transformations): Обработка данных на лету

Трансформации позволяют манипулировать данными **после того, как они были получены из источника данных, но до того, как они будут визуализированы**. Это невероятно мощный инструмент, который позволяет:

- **Filter data by values:** Отфильтровать строки или серии по значению.

- **Filter data by name:** Отфильтровать серии по имени.

- **Organize fields:** Переименовать, переупорядочить или скрыть поля.

- **Join by field:** Объединить результаты нескольких запросов по общему полю (например, `instance`).

- **Merge:** Объединить результаты нескольких запросов в один.

- **Add field from calculation:** Создать новое поле на основе математических операций над существующими полями (например, `A + B`, `A / B * 100`).

- **Group by:** Агрегировать данные по одному или нескольким полям, применяя функции `sum`, `avg`, `count`, `min`, `max`.

- **Labels to fields:** Преобразовать метки временных рядов в поля таблицы.

- **Reduce row:** Свернуть несколько строк в одну, применяя агрегирующие функции.

Трансформации выполняются на Frontend, что позволяет избежать повторных запросов к источнику данных и дает большую гибкость в представлении информации.

### 4.3. Переменные (Variables): Динамические и интерактивные дашборды

Переменные делают дашборды интерактивными и многоразовыми. Вместо создания отдельных дашбордов для каждого микросервиса или окружения, вы можете создать один универсальный дашборд с переменными.

- **Query Variable:** Значения переменной получаются из запроса к источнику данных. Например, список всех `job` или `instance` из Prometheus: `label_values(up, job)`.

- **Custom Variable:** Задается вручную список значений.

- **Text Box Variable:** Позволяет пользователю ввести произвольный текст.

- **Constant Variable:** Скрытая переменная с фиксированным значением, полезно для Provisioning.

- **Ad-hoc filters:** Специальный тип переменной, который позволяет пользователю добавлять произвольные фильтры (label=value) ко всем запросам на дашборде. Это очень удобно для динамической фильтрации по меткам.

Переменные могут быть связаны друг с другом (chained variables), что позволяет создавать каскадные выпадающие списки (например, сначала выбрать регион, затем кластер, затем сервис).

### 4.4. Library Panels & Rows: Переиспользование компонентов

Для повышения эффективности и консистентности Grafana предлагает концепцию **Library Panels** и **Library Rows**.

- **Library Panels:** Позволяют сохранить любую панель как переиспользуемый компонент. Если вы измените Library Panel, все дашборды, использующие её, автоматически обновятся. Это идеально для стандартизации ключевых метрик (например, QPS, Latency) по всем вашим сервисам.

- **Library Rows:** Аналогично, можно сохранять целые ряды панелей. Это полезно для создания стандартных секций дашборда (например, "Обзор CPU", "Обзор памяти").

Эти функции значительно упрощают управление большим количеством дашбордов и обеспечивают их единообразие.

---

## 5. Grafana Unified Alerting: Интеллектуальные оповещения

Начиная с Grafana 9, система алертинга была полностью переработана и унифицирована. Теперь она позволяет создавать, управлять и маршрутизировать алерты из всех подключенных источников данных, а не только из Prometheus.

### 5.1. Ключевые концепции

- **Alert Rule:** Определяет условие, при котором должен сработать алерт. Может быть основано на запросах к Prometheus, Loki, Elasticsearch, SQL-базам и т.д.

- **Contact Point:** Определяет, куда отправлять уведомления (Slack, Email, PagerDuty, Webhook, Microsoft Teams, Telegram).

- **Notification Policy:** Определяет, какие алерты (по меткам) куда отправлять, а также группировку, дедупликацию и задержки.

- **Silences:** Временное отключение оповещений для конкретных алертов или групп алертов (например, во время плановых работ).

- **Mutes:** Позволяют заглушить алерты, которые соответствуют определенным меткам, на постоянной основе.

### 5.2. Multi-Source Alerting

Унифицированный алерт может проверять условия из нескольких источников данных одновременно. Например, алерт может сработать, если:

- `Prometheus: CPU > 90%` И `Loki: количество ошибок в логах > 100` И `PostgreSQL: количество активных соединений > 50`.

Это позволяет создавать более сложные и точные правила оповещения, уменьшая количество ложных срабатываний.

### 5.3. Alerting в контексте OrderHub

Для проекта OrderHub можно настроить алерты на:

- **Технические проблемы:** Высокий процент 5xx ошибок, высокая задержка HTTP-запросов, падение сервиса (`up == 0`).

- **Бизнес-проблемы:** Резкое падение скорости создания заказов, большое количество отмененных заказов, низкий уровень запасов (если данные есть в SQL).

---

## 6. Provisioning: Infrastructure as Code для Grafana

Ручное создание и управление дашбордами в UI Grafana не масштабируется. В production-средах используется **Provisioning** — подход "Dashboard as Code" или "Configuration as Code".

### 6.1. Автоматизация конфигурации

Grafana может быть настроена на автоматическую загрузку источников данных, дашбордов, нотификаций и плагинов из файлов на диске. Это позволяет:

- **Версионирование:** Все конфигурации хранятся в Git, что позволяет отслеживать изменения, проводить Code Review и откатываться к предыдущим версиям.

- **Повторяемость:** Легко разворачивать идентичные инстансы Grafana в разных окружениях (Dev, Staging, Prod).

- **Автоматизация:** Интеграция с CI/CD пайплайнами для автоматического деплоя изменений.

### 6.2. Структура Provisioning

Файлы Provisioning обычно располагаются в `/etc/grafana/provisioning/` и делятся на категории:

- `datasources/`: YAML-файлы для источников данных.

- `dashboards/`: YAML-файлы, указывающие на директории с JSON-файлами дашбордов.

- `notifiers/`: YAML-файлы для контактных точек и политик нотификаций.

**Пример ****`datasources/prometheus.yaml`****:**

```yaml
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    url: http://prometheus:9090
    access: proxy
    isDefault: true
    version: 1
    editable: false # Запретить редактирование через UI
```

**Пример ****`dashboards/orderhub.yaml`****:**

```yaml
apiVersion: 1
providers:
  - name: 'OrderHub Dashboards'
    orgId: 1
    folder: 'OrderHub'
    type: file
    disableDeletion: true
    editable: false
    options:
      path: /var/lib/grafana/dashboards/orderhub # Путь к JSON-файлам дашбордов
```

### 6.3. Генерация JSON-дашбордов: `jsonnet` (Grafonnet ) и `grafana-sculptor`

Ручное написание JSON для дашбордов — трудоемкий процесс. Для решения этой проблемы используются инструменты кодогенерации:

- **Jsonnet (Grafonnet):** Jsonnet — это конфигурационный язык, который позволяет генерировать JSON. Grafonnet — это библиотека Jsonnet, предоставляющая удобные функции для создания Grafana-дашбордов. Это позволяет писать дашборды как код, используя циклы, условия и переиспользуемые компоненты.

- **grafana-sculptor:** Python-библиотека, которая позволяет программно создавать JSON-дашборды. Удобно для тех, кто предпочитает Python.

Эти инструменты позволяют создавать сложные, динамические и легко поддерживаемые дашборды, полностью управляемые кодом.

---

## 7. Безопасность и масштабирование Grafana

Grafana — это критически важный компонент инфраструктуры, поэтому вопросы безопасности и масштабирования стоят остро.

### 7.1. Безопасность

- **Аутентификация:** Поддержка различных провайдеров: LDAP, OAuth (Google, GitHub, Azure AD), SAML, Reverse Proxy Auth.

- **Авторизация (RBAC):** Гранулярный контроль доступа к дашбордам, папкам, источникам данных и функциям. В Enterprise-версии доступен более продвинутый RBAC.

- **Организации и пользователи:** Grafana поддерживает концепцию организаций, что позволяет изолировать данные и дашборды для разных команд или клиентов.

- **API Keys:** Для программного доступа к Grafana API.

### 7.2. Масштабирование и High Availability (HA)

Grafana может быть масштабирована горизонтально для обеспечения высокой доступности и обработки большого количества запросов.

- **Load Balancer:** Несколько инстансов Grafana размещаются за балансировщиком нагрузки.

- **Shared Database:** Все инстансы Grafana должны использовать общую внешнюю базу данных (PostgreSQL или MySQL) для хранения метаданных.

- **Shared Storage:** Для хранения плагинов, изображений и других файлов Grafana может использовать общее хранилище (например, NFS, S3).

- **External Session Store (Redis):** Для обеспечения отказоустойчивости сессий пользователей, особенно при использовании OAuth, рекомендуется использовать внешнее хранилище сессий, такое как Redis.

- **Caching:** Grafana поддерживает кэширование запросов к источникам данных, что снижает нагрузку на них и ускоряет загрузку дашбордов.

---

## 8. Ссылки для дальнейшего изучения

- [Официальная документация Grafana](https://grafana.com/docs/)

- [Grafana Play (Демо-дашборды)](https://play.grafana.org/)

- [Grafana Dashboard Library (Готовые шаблоны)](https://grafana.com/grafana/dashboards/)

- [Grafana Labs Blog](https://grafana.com/blog/)

- [Jsonnet (Grafonnet) for Grafana](https://grafana.com/docs/grafana/latest/administration/provisioning/#jsonnet)

- [Prometheus Ultimate Deep Dive (наше руководство)](/home/ubuntu/PROMETHEUS_ULTIMATE_DEEP_DIVE.md)

- [Micrometer Deep Dive (наше руководство)](/home/ubuntu/MICROMETER_DEEP_DIVE.md)